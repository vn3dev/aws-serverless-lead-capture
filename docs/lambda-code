import { SESClient, SendEmailCommand } from "@aws-sdk/client-ses";
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import { DynamoDBDocumentClient, PutCommand } from "@aws-sdk/lib-dynamodb";
import { randomUUID, createHash } from "crypto";

// ✅ ENV
const REGION = mustEnv("AWS_REGION");
const TABLE_NAME = mustEnv("TABLE_NAME");
const RECEIVER = mustEnv("RECEIVER_EMAIL");
const SENDER = mustEnv("SENDER_EMAIL");

// ✅ Clients
const ses = new SESClient({ region: REGION });
const ddb = DynamoDBDocumentClient.from(new DynamoDBClient({ region: REGION }));

const EMAIL_RE = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

const ALLOWED_ORIGINS = new Set([
  "https://vn3infra.com",
  "https://www.vn3infra.com",
]);

const LIMITS = {
  name: 100,
  email: 254,
  phone: 30,
  message: 1000,
};

const MAX_BODY_CHARS = 2000;

const TTL_DAYS = 90;
const TTL_SECONDS = TTL_DAYS * 24 * 60 * 60;

export const handler = async (event) => {
  const requestId = event?.requestContext?.requestId;
  const method = event?.httpMethod;
  const origin = event?.headers?.origin || event?.headers?.Origin || "";
  console.log("request", JSON.stringify({ requestId, method, origin }));

  if (method === "OPTIONS") {
    return { statusCode: 204, headers: corsHeaders(event), body: "" };
  }

  const envCheck = validateRuntimeConfig();
  if (!envCheck.ok) {
    console.error("config_error", envCheck);
    return {
      statusCode: 500,
      headers: corsHeaders(event),
      body: JSON.stringify({
        error: "Service misconfigured",
        missing: envCheck.missing,
      }),
    };
  }

  try {
    const parsed = parseJsonBody(event, MAX_BODY_CHARS);
    if (!parsed.ok) {
      return {
        statusCode: parsed.statusCode,
        headers: corsHeaders(event),
        body: JSON.stringify({ error: parsed.error }),
      };
    }

    const body = parsed.data;

    const name = sanitize(body?.name, LIMITS.name);
    const email = sanitize(body?.email, LIMITS.email).toLowerCase();
    const phone = sanitize(body?.phone, LIMITS.phone);
    const message = sanitize(body?.message, LIMITS.message);

    if (!name || !email) {
      return {
        statusCode: 400,
        headers: corsHeaders(event),
        body: JSON.stringify({ error: "name and email are required" }),
      };
    }

    if (!EMAIL_RE.test(email)) {
      return {
        statusCode: 400,
        headers: corsHeaders(event),
        body: JSON.stringify({ error: "invalid email format" }),
      };
    }

    const submissionId = randomUUID();
    const ts = new Date().toISOString();

    const day = ts.slice(0, 10);
    const dedupeKey = sha256(`${email}|${message}|${day}`);

    const expiresAt = Math.floor(Date.now() / 1000) + TTL_SECONDS;

    try {
      await ddb.send(
        new PutCommand({
          TableName: TABLE_NAME,
          Item: {
            id: dedupeKey,
            submissionId,
            name,
            phone,
            email,
            message,
            createdAt: ts,
            expiresAt,
          },
          ConditionExpression: "attribute_not_exists(id)",
        })
      );
    } catch (e) {
      if (e?.name === "ConditionalCheckFailedException") {
        return {
          statusCode: 200,
          headers: corsHeaders(event),
          body: JSON.stringify({ ok: true, duplicate: true }),
        };
      }
      throw e;
    }

    const emailMasked = maskEmail(email);

    const params = {
      Destination: { ToAddresses: [RECEIVER] },
      Message: {
        Subject: { Data: `Website Query Form: ${name}`, Charset: "UTF-8" },
        Body: {
          Text: {
            Data: `Full Name: ${name}
Phone: ${phone}
Email: ${emailMasked}
Message: ${message}
ID: ${submissionId}
Time: ${ts}`,
            Charset: "UTF-8",
          },
        },
      },
      Source: SENDER,
      ReplyToAddresses: [email],
    };

    await ses.send(new SendEmailCommand(params));

    return {
      statusCode: 200,
      headers: corsHeaders(event),
      body: JSON.stringify({ ok: true, id: submissionId }),
    };
  } catch (err) {
    console.error("Error:", err);
    return {
      statusCode: 500,
      headers: corsHeaders(event),
      body: JSON.stringify({ error: "Internal error" }),
    };
  }
};

function corsHeaders(event) {
  const origin = event?.headers?.origin || event?.headers?.Origin || "";
  const allowOrigin = ALLOWED_ORIGINS.has(origin) ? origin : "null";

  return {
    "Content-Type": "application/json",
    "Access-Control-Allow-Origin": allowOrigin,
    "Vary": "Origin",
    "Access-Control-Allow-Methods": "OPTIONS,POST",
    "Access-Control-Allow-Headers": "Content-Type",
  };
}

function parseJsonBody(event, maxChars) {
  const raw = event?.body;
  if (!raw) return { ok: true, data: {}, rawLength: 0 };

  let text = raw;

  if (event?.isBase64Encoded === true) {
    try {
      text = Buffer.from(raw, "base64").toString("utf8");
    } catch {
      return { ok: false, statusCode: 400, error: "invalid base64 body" };
    }
  }

  if (text.length > maxChars) {
    return { ok: false, statusCode: 413, error: "message too long" };
  }

  try {
    const data = JSON.parse(text);
    return { ok: true, data };
  } catch {
    return { ok: false, statusCode: 400, error: "invalid JSON" };
  }
}

function sanitize(value, maxLen) {
  if (!value) return "";
  const str = String(value).trim();
  return str.length > maxLen ? str.slice(0, maxLen) : str;
}

function maskEmail(email) {
  const parts = email.split("@");
  if (parts.length !== 2) return email;
  const [user, domain] = parts;
  return `${user[0]}***@${domain}`;
}

function sha256(input) {
  return createHash("sha256").update(String(input)).digest("hex");
}

function mustEnv(key) {
  const v = process.env[key];
  return v && String(v).trim() ? String(v).trim() : "";
}

function validateRuntimeConfig() {
  const required = {
    AWS_REGION: REGION,
    TABLE_NAME,
    RECEIVER_EMAIL: RECEIVER,
    SENDER_EMAIL: SENDER,
  };

  const missing = Object.entries(required)
    .filter(([, v]) => !v)
    .map(([k]) => k);

  return { ok: missing.length === 0, missing };
}